{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tenauth Overview","text":"<p>Tenauth provides a focused toolkit for building multi-tenant FastAPI services backed by SQLModel. The package handles JWT decoding, access-context management, and tenant-aware database sessions so your endpoints stay thin and declarative.</p>"},{"location":"#key-capabilities","title":"Key Capabilities","text":"<ul> <li>Bearer Auth Parsing \u2013 <code>tenauth.models.AuthContext</code> converts Authorization headers into typed payloads with minimal boilerplate.</li> <li>Tenant-Scoped Sessions \u2013 <code>tenauth.session.access_scoped_session_ctx</code> applies Postgres GUCs to each connection, keeping tenant and user scope consistent.</li> <li>FastAPI Dependencies \u2013 <code>tenauth.fastapi.require_auth</code> and <code>build_access_scoped_session_dependency</code> wire the auth and session layers into your routers.</li> <li>DSN Augmentation \u2013 <code>tenauth.tenancy.dsn_with_tenant</code> injects tenant identifiers into connection strings for background jobs or migrations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>uv pip sync\n</code></pre> <p>If <code>uv</code> is not available, create a virtual environment and install the project in editable mode:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate\npip install -e .[dev]\n</code></pre>"},{"location":"#project-layout","title":"Project Layout","text":"<ul> <li><code>src/tenauth/</code> \u2013 core library modules (FastAPI dependency helpers, session utilities, models, tenancy helpers).</li> <li><code>tests/</code> \u2013 pytest suite covering JWT parsing and dependency behavior.</li> <li><code>pyproject.toml</code> / <code>uv.lock</code> \u2013 packaging metadata and pinned dependency set.</li> </ul> <p>Continue through the remaining sections for detailed guidance on integrating the components into your service.</p>"},{"location":"development/","title":"Development Guide","text":""},{"location":"development/#environment-setup","title":"Environment Setup","text":"<ul> <li>Install dependencies with <code>uv pip sync</code>. This ensures versions locked in <code>uv.lock</code> are applied.</li> <li>If <code>uv</code> is unavailable, create a virtual environment and run <code>pip install -e .[dev]</code>.</li> <li>Target Python 3.12 to align with the <code>pyproject.toml</code> specification.</li> </ul>"},{"location":"development/#running-tests","title":"Running Tests","text":"<ul> <li>Execute the full suite with <code>uv run pytest</code>.</li> <li>Use markers or keyword selection for focused runs, e.g. <code>uv run pytest -k auth</code>.</li> <li>Add async tests with <code>pytest.mark.asyncio</code> when asserting session or FastAPI behaviours.</li> </ul>"},{"location":"development/#coding-standards","title":"Coding Standards","text":"<ul> <li>Follow four-space indentation and <code>snake_case</code> for functions/variables; models stay in <code>PascalCase</code>.</li> <li>Keep modules cohesive: FastAPI dependencies in <code>fastapi.py</code>, session utilities in <code>session.py</code>, models in <code>models.py</code>.</li> <li>Prefer raising <code>HTTPException</code> for user-facing errors and domain-specific exceptions (<code>ValueError</code>, <code>RuntimeError</code>) for invariants.</li> <li>Configure logging with the stdlib <code>logging</code> module; the package initialises <code>logger = logging.getLogger(__name__)</code> where needed.</li> </ul>"},{"location":"development/#contributing","title":"Contributing","text":"<ul> <li>Review <code>AGENTS.md</code> for repository guidelines on commit messages, PR requirements, and expected test evidence.</li> <li>Scope commits to a single logical change and keep messages in the imperative mood.</li> <li>Document behaviour changes and new configuration steps within the relevant Markdown pages before requesting review.</li> </ul>"},{"location":"fastapi/","title":"FastAPI Integration","text":"<p>FastAPI dependencies in Tenauth minimise boilerplate for enforcing bearer authentication and tenant scoping.</p>"},{"location":"fastapi/#requiring-authentication","title":"Requiring Authentication","text":"<pre><code>from fastapi import Depends, FastAPI\nfrom tenauth.fastapi import require_auth\nfrom tenauth.models import AuthContext\n\napp = FastAPI()\n\n@app.get(\"/me\")\ndef read_profile(auth: AuthContext = Depends(require_auth)):\n    return {\"user_id\": str(auth.sub), \"tenant_id\": str(auth.tid)}\n</code></pre> <p><code>require_auth</code> extracts the bearer token, validates the scheme, and returns an <code>AuthContext</code>. Invalid or missing tokens raise <code>HTTPException(status_code=401)</code> automatically.</p>"},{"location":"fastapi/#tenant-aware-sessions","title":"Tenant-Aware Sessions","text":"<pre><code>from sqlmodel.ext.asyncio.session import AsyncSession\nfrom tenauth.fastapi import build_access_scoped_session_dependency\n\nSessionDep = build_access_scoped_session_dependency(session_factory=my_session_factory)\n\n@app.get(\"/tenants/{tenant_id}/widgets\")\nasync def list_widgets(session: AsyncSession = Depends(SessionDep)):\n    result = await session.execute(...)\n    return result.all()\n</code></pre> <p><code>build_access_scoped_session_dependency</code> combines the auth context with the session factory. It applies tenant and user identifiers via Postgres GUCs for the lifecycle of the request and resets them when complete.</p>"},{"location":"fastapi/#customising-verification","title":"Customising Verification","text":"<p>When creating the dependency you can disable runtime GUC verification:</p> <pre><code>SessionDep = build_access_scoped_session_dependency(\n    session_factory=my_session_factory,\n    verify=False,\n)\n</code></pre> <p>Skipping verification removes the extra roundtrip to confirm the settings\u2014but only use it when you trust the database connection pool configuration.</p>"},{"location":"models/","title":"Models &amp; Auth","text":"<p>Models in Tenauth are Pydantic-based wrappers around the auth and access concepts used throughout the project.</p>"},{"location":"models/#authcontext","title":"AuthContext","text":"<p><code>AuthContext</code> represents the decoded JWT payload. The <code>from_token</code> classmethod: - Splits the token into header/payload/signature. - Base64-decodes the payload, enriching the data with strongly typed UUIDs. - Normalises scopes into a list of strings. - Converts <code>plan</code> or <code>entitlements</code> fields into a single attribute.</p> <p>On failure it logs a warning via the standard library logger and raises <code>HTTPException(status_code=401)</code>. Catch the exception in higher layers when you need custom responses.</p>"},{"location":"models/#example","title":"Example","text":"<pre><code>from tenauth.models import AuthContext\n\nauth = AuthContext.from_token(encoded_jwt)\nprint(auth.sub, auth.tid, auth.scopes)\n</code></pre>"},{"location":"models/#accesscontext","title":"AccessContext","text":"<p><code>AccessContext</code> is a minimal tenant/user pair used by the session helpers.</p> <pre><code>from tenauth.models import AccessContext\n\nctx = AccessContext.from_session(session)\n</code></pre> <p>The <code>from_session</code> helper fetches the UUIDs stored in <code>session.info</code> and raises <code>ValueError</code> when metadata is missing\u2014useful when integrating with third-party session factories or middleware.</p>"},{"location":"models/#error-handling-patterns","title":"Error Handling Patterns","text":"<ul> <li>Raise <code>HTTPException</code> for invalid client requests (missing tokens, malformed payloads).</li> <li>Use <code>RuntimeError</code> or <code>ValueError</code> when asserting internal invariants such as mismatched tenant IDs between a session and request context.</li> <li>Configure logging with <code>logging.basicConfig(level=\"INFO\")</code> or your preferred setup to surface parsing failures detected by <code>AuthContext</code>.</li> </ul>"},{"location":"session/","title":"Session Management","text":"<p>The session utilities ensure every database query runs within the correct tenant and user scope by applying Postgres Grand Unified Configurations (GUCs).</p>"},{"location":"session/#applying-access-context","title":"Applying Access Context","text":"<p><code>apply_access_context(session, access_context)</code> sets <code>app.tenant_id</code> and <code>app.user_id</code> on the active connection and stores the UUIDs in <code>session.info</code>.</p> <pre><code>from tenauth.models import AccessContext\nfrom tenauth.session import apply_access_context\n\nawait apply_access_context(\n    session,\n    access_context=AccessContext(tenant_id=tenant, user_id=user),\n)\n</code></pre>"},{"location":"session/#verification","title":"Verification","text":"<p>By default <code>apply_access_context</code> calls <code>verify_access_context</code>, which reads the current settings and compares them to the expected UUIDs. Failures raise <code>RuntimeError</code> to surface configuration problems immediately. Toggle verification off when you want to optimise for throughput and already have strong invariants on the pool.</p>"},{"location":"session/#resetting-context","title":"Resetting Context","text":"<p><code>reset_access_context(session)</code> clears both GUCs and removes stored metadata. This is called automatically inside <code>access_scoped_session_ctx</code>, but you can invoke it manually when using sessions outside the context manager.</p>"},{"location":"session/#scoped-context-manager","title":"Scoped Context Manager","text":"<p><code>access_scoped_session_ctx</code> wraps a provided session factory and yields an <code>AsyncSession</code> with the context bound for the duration of the <code>async with</code> block. It is the basis for the FastAPI dependency but can be reused in background tasks or scripts.</p> <pre><code>from tenauth.session import access_scoped_session_ctx\n\nasync with access_scoped_session_ctx(\n    session_factory=my_session_factory,\n    access_context=AccessContext(tenant_id=tenant, user_id=user),\n) as session:\n    ...\n</code></pre>"},{"location":"tenancy/","title":"Tenancy Utilities","text":"<p><code>tenauth.tenancy</code> contains helpers that keep tenant identifiers attached to database connections and downstream tooling.</p>"},{"location":"tenancy/#dsn_with_tenant","title":"dsn_with_tenant","text":"<p>This function injects the tenant UUID into the DSN query portion, extending existing connection options when present.</p> <pre><code>from tenauth.tenancy import dsn_with_tenant\n\ntenant_dsn = dsn_with_tenant(\n    \"postgresql+psycopg://svc@db.example.com/app?sslmode=require\",\n    tenant_id=tenant_uuid,\n)\n</code></pre> <p>Internally it uses <code>urllib.parse</code> to preserve other connection parameters. If <code>options</code> already contain tenant-related flags they are augmented in-place to avoid duplicates.</p>"},{"location":"tenancy/#usage-scenarios","title":"Usage Scenarios","text":"<ul> <li>Background Workers \u2013 Derive per-tenant DSNs when enqueueing tasks or spinning up dedicated workers.</li> <li>Migrations \u2013 Generate tenant-specific connection strings for migration scripts that rely on <code>psql</code> command-line arguments.</li> <li>Diagnostics \u2013 Craft diagnostic queries tied to a tenant without mutating your primary configuration files.</li> </ul> <p>Pair the helper with session utilities to ensure the tenant context is represented consistently across service layers.</p>"}]}